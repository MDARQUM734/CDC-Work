Question 231
class Solution {
    public boolean isPowerOfTwo(int n) {
        if(n == 1) return true;
        if(n<=0 || n%2 != 0) return false;
        return isPowerOfTwo(n/2);
    }
}

Question 338
class Solution {
    public int[] countBits(int n) {
       int dp[]=new int[n+1];
       for(int i=1; i<n+1; i++){
        // yaha dp[i>>i] ye isleye kar rahe kyoki hame just phle wale dp[i] ka pata hai jais agar i = 111 to hame dp[11] ka pata hai aur phir ham add kar rahe kyoki last bit agar one hai toh add karenge warna 0 aa jayega 
        dp[i] = dp[i>>1]+(i & 1);
       }
       return dp;
    }
}

Question kth bit
class CheckBit {
    static boolean checkKthBit(int n, int k) {
        // code here
        if((n & (1<<k)) != 0) return true;
        else return false;
    }
}
Question Toggle bits range
class Solution {
    static int toggleBits(int n, int l, int r) {
        // code here
        int mask = ((1<<(r-l+1))-1) << (l-1);
        return mask^n;
    }
};

Question 136
class Solution {
    public int singleNumber(int[] nums) {
        int n = nums.length;
        int result = 0;
        for(int i=0; i<n; i++){
            result ^= nums[i];
        }
        return result;
    }
Question 137
class Solution {
    public int singleNumber(int[] nums) {
        int n =nums.length;
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int num : nums){
            map.put(num,map.getOrDefault(num,0)+1);
        }
        for(int num : map.keySet()){
            if(map.get(num) == 1) return num;
        }
        return -1;
    }
}
    Question 78
    class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(0, nums, new ArrayList<>(), result);
        return result;
    }
    public void backtrack(int start, int nums[],List<Integer> current, List<List<Integer>> result){
        result.add(new ArrayList<>(current));
        for(int i=start ; i<nums.length; i++){
            current.add(nums[i]);
            backtrack(i+1,nums,current,result);
            current.remove(current.size()-1);
        }
    }
}
Question 268
class Solution {
    public int missingNumber(int[] nums) {
     int xor = 0;
        int n = nums.length;

        // XOR all numbers from 0 to n
        for (int i = 0; i <= n; i++) {
            xor ^= i;
        }
        for (int num : nums) {
            xor ^= num;
        }
        return xor;
    }
}
}
Question Count Set bit
class Solution {
    public static int countSetBits(int n) {
        // code here
        int dp[] = new int[n+1];
        for(int i=1; i<n+1; i++){
            dp[i] = dp[i>>1] + (i & 1);
        }
        int sum = 0;
        for(int i=0; i<=n; i++){
            sum += dp[i];
        }
        return sum;
    }
}
Question 287
class Solution {
    public int findDuplicate(int[] nums) {
        int n = nums.length;
        HashSet<Integer> set = new HashSet<>();
        for(int num : nums){
            if(!set.contains(num)){
                set.add(num);
            }else return num;
        }
        return -1;
    }
}
Question 204
class Solution {
    public boolean isPrime(int n){
        for(int i=2; i * i <=n ; i++){
            if(n%i == 0) return false;
        }
        return true;
    }
    public int countPrimes(int n) {
        int count = 0;
        for(int i=2; i<n; i++){
            if(isPrime(i)){
                count++;
            }
        }
        return count;
    }
}
Question 1015
class Solution {
    public int smallestRepunitDivByK(int k) {
        if(k%2 == 0 || k%5 == 0){
            return -1;
        }
        int r = 0;
        for(int length = 1; length<=k; length++){
            r = (r*10 +1)%k;
            if(r == 0){
                return length;
            }
        }
        return -1;
    }
}
question 96
class Solution {
    public int numTrees(int n) {
        int dp[] = new int[n+1];
        dp[0]=1;
        dp[1]=1;
        for(int i=2; i<n+1; i++){
            for(int j=0; j<i; j++){
                int left = dp[j];
                int right = dp[i-j-1];
                dp[i] += left*right;
            }
        }
        return dp[n];
    }
}
Question 46
class Solution {
    public void backtrack(int nums[],List<Integer>path,List<List<Integer>> result){
        if(path.size() == nums.length){
            result.add(new ArrayList<>(path));
            return;
        }
        for(int num : nums){
            if(path.contains(num)) continue;
            path.add(num);
            backtrack(nums,path,result);
            path.remove(path.size()-1);
        }
    }
    public List<List<Integer>> permute(int[] nums) {
        int n = nums.length;
        List<List<Integer>> result = new ArrayList<>();
        backtrack(nums,new ArrayList<>(), result);
        return result;
    }
}
