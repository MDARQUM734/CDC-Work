Question. implement lower bound
class Solution {
    int lowerBound(int[] arr, int target) {
        // code here
        int n = arr.length;
        int low = 0, high = n-1;
        int ans = n;
        while(low <= high){
            int mid = low + (high - low)/2;
            if(arr[mid] >= target){
                ans = mid;
                high = mid-1;
            } else{
                low = mid+1;
            }
        }
        return ans;
    }
}


Question 278
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int low = 0, high = n;
        int ans = 0;
        while(low <= high){
            int mid = low + (high-low)/2;
            if(isBadVersion(mid)){
                ans = mid;
                high = mid-1;
            }else{
                low = mid + 1;
            }
        }
        return ans;
    }

    
    Question 104
    class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        return 1 + Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
}

Question 33(LC)
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        int low = 0, high = n-1;
        while(low <= high){
            int mid = low + (high-low)/2;
            if(nums[mid] == target) return mid;
            if(nums[mid] >= nums[low]){
                if(nums[low] <= target && target <= nums[mid]){
                    high = mid-1;
                }else{
                    low = mid+1;
                }
            }else{
                if(target >= nums[mid] && target <= nums[high]){
                    low = mid+1;
                }else{
                    high = mid - 1;
                }
            }
        }
        return -1;
    }
}
Question 81
class Solution {
    public boolean search(int[] nums, int target) {
        int n = nums.length;
        int low = 0;
        int high = n-1;
        while(low <= high){
            int mid = low + (high-low)/2;
            if(nums[mid] == target) return true;
            if(nums[low] == nums[mid] && nums[high] == nums[mid]){
                low++;
                high--;
            }
            else if(nums[low] <= nums[mid] ){
                if(nums[low] <= target && nums[low] < target){
                    high = mid-1;
                }else{
                    low = mid +1;
                }
            }else{
                if(target > nums[mid] && target <= nums[high]){
                    low = mid +1;
                }else{
                    high = mid -1;
                }
            }
        }
        return false;
    }
}
Question 2196
class Solution {
    public TreeNode createBinaryTree(int[][] descriptions) {
        int n = descriptions.length;
        int m = descriptions[0].length;
        HashMap<Integer,TreeNode> map = new HashMap<>();
        HashSet<Integer> set = new HashSet<>();
        for(int d[] : descriptions){
            int parentVal = d[0];
            int childVal = d[1];
            int isChild = d[2];

            map.putIfAbsent(parentVal,new TreeNode(parentVal));
            map.putIfAbsent(childVal, new TreeNode(childVal));
            TreeNode parent = map.get(parentVal);
            TreeNode child = map.get(childVal);
            if(isChild == 1){
                parent.left = child;
            }else{
                parent.right = child;
            }
            set.add(childVal);
        }
        TreeNode root = null;
        for(int val : map.keySet()){
            if(!set.contains(val)){
                root = map.get(val);
                break;
            }
        }
        return root;
    }
}
Question 144(LC)
class Solution {
    public void helper(TreeNode root, List<Integer> list){
        if(root == null) return;
        list.add(root.val);
        helper(root.left,list);
        helper(root.right,list);
    }
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if(root == null) return list;
        helper(root,list);
        return list;
    }
}
Question 94
class Solution {
    public void helper(TreeNode root, List<Integer> list){
        if(root == null) return;
        helper(root.left,list);
        list.add(root.val);
        helper(root.right,list);
    }
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if(root == null) return list;
        helper(root,list);
        return list;
    }
}
Question 145(LC)
class Solution {
    public void helper(TreeNode root, List<Integer> list){
        if(root == null) return;
        helper(root.left,list);
        helper(root.right,list);
        list.add(root.val);
    }
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if(root == null) return list;
        helper(root,list);
        return list;
    }
}
Question 102
class Solution {
    public int height(TreeNode root){
        if(root == null || (root.left == null && root.right == null)) return 0;
        return 1+Math.max(height(root.left),height(root.right));
    }
    public void nthLevel(TreeNode root, int n, List<Integer> list){
        if(root == null) return;
        if(n == 1){
            list.add(root.val);
            return;
        }
        nthLevel(root.left,n-1,list);
        nthLevel(root.right,n-1,list);
    }
    public List<List<Integer>> levelOrder(TreeNode root) {
        int level = height(root) + 1;
        List<List<Integer>> res = new ArrayList<>();
        if(root == null) return res;
        for(int i=1; i<=level; i++){
            List<Integer> list = new ArrayList<>();
            nthLevel(root,i,list);
            res.add(list);
        }
        return res;
    }
}
Question 100
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) return true;
        if(p==null || q== null) return false;
        if(p.val != q.val) return false;
        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
    }
}
Question 101
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) return true;
        if(p==null || q== null) return false;
        if(p.val != q.val) return false;
        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
    }
    public TreeNode invert(TreeNode root){
        if(root == null) return null;
        TreeNode left = root.left;
        TreeNode right = root.right;
        root.left = right;
        root.right = left;
        invert(root.left);
        invert(root.right);
        return root;
    }
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        if(isSameTree(root.left,invert(root.right))) return true;
        return false;
    }
}
