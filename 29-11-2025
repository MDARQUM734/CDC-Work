LC 322
class Solution {
    public int helper(int[] coins, int amount,int idx, int dp[][]){
        if(amount == 0) return 0;
        if(coins.length == idx || amount < 0){
            return Integer.MAX_VALUE-1;
        }
        if(dp[idx][amount] != -1){
            return dp[idx][amount];
        }
        int ans1 = 1 + helper(coins,amount-coins[idx],idx,dp);
        int ans2 = helper(coins,amount,idx+1,dp);
        return dp[idx][amount] = Math.min(ans1,ans2);
    }
    public int coinChange(int[] coins, int amount) {
        int n = coins.length;
        int dp[][] = new int[n][amount+1];
        for(int i=0; i<n; i++){
            for(int j=0; j<amount+1; j++){
                dp[i][j] = -1;
            }
        }
        int ans = helper(coins,amount,0,dp);
        if(ans != Integer.MAX_VALUE-1) return ans;
        else  return -1;
    }
}
LC 518
class Solution {
    public int change(int amount, int[] coins) {
        int n = coins.length;
        int dp[] = new int[amount+1];
        dp[0] = 1;
        for(int coin : coins){
            for(int i=coin; i<=amount; i++){
                dp[i] += dp[i-coin];
            }
        }
        return dp[amount];
    }
}


LC 55
class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int  far =0; 
        for(int i=0; i<n; i++){
            if(i > far) return false;
            far =Math.max(far,nums[i]+i);
        }
        return true;
    }
}

LC 45
class Solution {
    public int jump(int[] nums) {
       int n = nums.length;
       int jump =0, curr =0, far=0;
       for(int i =0; i<n-1; i++){
        far = Math.max(far,nums[i]+i);
        if(i== curr){
            jump++;
            curr = far;
        }
       }
       return jump;
    }
}

LC 1143
class Solution {
    public int lcs(String text1, String text2, int n , int m, int dp[][]){
        if(n == 0 || m == 0) return 0;
        if(dp[n][m] != -1){
            return dp[n][m];
        }
        if(text1.charAt(n-1) == text2.charAt(m-1)){
            dp[n][m] = 1 + lcs(text1,text2,n-1,m-1,dp);
        } else{
            dp[n][m] = Math.max(lcs(text1,text2,n-1,m,dp),lcs(text1,text2,n,m-1,dp));
        }
        return dp[n][m];
    }
    public int longestCommonSubsequence(String text1, String text2) {
        int n = text1.length();
        int m = text2.length();
        int dp[][] = new int[n+1][m+1];
        for(int i=0; i<=n; i++){
            for(int j=0; j<=m; j++){
                dp[i][j] = -1;
            }
        }
        return lcs(text1,text2,n,m,dp);
    }
}

LC 5
class Solution {
    public boolean lcs(String str,int i, int j){
        if(i>=j) return true;
        if(str.charAt(i) == str.charAt(j)){
            return lcs(str,i+1,j-1);
        }
        return false;
    }
    public String longestPalindrome(String s) {
        int n = s.length();
        int maxLen = Integer.MIN_VALUE;
        int sp = 0;
        for(int i=0; i<n; i++){
            for(int j=i; j<n; j++){
                if(lcs(s,i,j)){
                    if(maxLen<j-i+1){
                        maxLen = j-i+1;
                        sp = i;
                    }
                }
            }
        }
        return s.substring(sp,sp+maxLen);
    }
}
